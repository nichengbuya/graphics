import { Observable } from 'rxjs';
/**
 *  Minimum definition needed by base class
 */
import * as ɵngcc0 from '@angular/core';
export interface HeadersCore {
    set(name: string, value: string): void | any;
}
/**
* Interface for a class that creates an in-memory database
*
* Its `createDb` method creates a hash of named collections that represents the database
*
* For maximum flexibility, the service may define HTTP method overrides.
* Such methods must match the spelling of an HTTP method in lower case (e.g, "get").
* If a request has a matching method, it will be called as in
* `get(info: requestInfo, db: {})` where `db` is the database object described above.
*/
export declare abstract class InMemoryDbService {
    /**
    * Creates an in-memory "database" hash whose keys are collection names
    * and whose values are arrays of collection objects to return or update.
    *
    * returns Observable of the database because could have to create it asynchronously.
    *
    * This method must be safe to call repeatedly.
    * Each time it should return a new object with new arrays containing new item objects.
    * This condition allows the in-memory backend service to mutate the collections
    * and their items without touching the original source data.
    *
    * The in-mem backend service calls this method without a value the first time.
    * The service calls it with the `RequestInfo` when it receives a POST `commands/resetDb` request.
    * Your InMemoryDbService can adjust its behavior accordingly.
    */
    abstract createDb(reqInfo?: RequestInfo): {} | Observable<{}> | Promise<{}>;
}
/**
* Interface for InMemoryBackend configuration options
*/
export declare abstract class InMemoryBackendConfigArgs {
    /**
     * The base path to the api, e.g, 'api/'.
     * If not specified than `parseRequestUrl` assumes it is the first path segment in the request.
     */
    apiBase?: string;
    /**
     * false (default) if search match should be case insensitive
     */
    caseSensitiveSearch?: boolean;
    /**
     * false (default) put content directly inside the response body.
     * true: encapsulate content in a `data` property inside the response body, `{ data: ... }`.
     */
    dataEncapsulation?: boolean;
    /**
     * delay (in ms) to simulate latency
     */
    delay?: number;
    /**
     * false (default) should 204 when object-to-delete not found; true: 404
     */
    delete404?: boolean;
    /**
     * host for this service, e.g., 'localhost'
     */
    host?: string;
    /**
     * false (default) should pass unrecognized request URL through to original backend; true: 404
     */
    passThruUnknownUrl?: boolean;
    /**
     * true (default) should NOT return the item (204) after a POST. false: return the item (200).
     */
    post204?: boolean;
    /**
    * false (default) should NOT update existing item with POST. false: OK to update.
    */
    post409?: boolean;
    /**
    * true (default) should NOT return the item (204) after a POST. false: return the item (200).
    */
    put204?: boolean;
    /**
     * false (default) if item not found, create as new item; false: should 404.
     */
    put404?: boolean;
    /**
     * root path _before_ any API call, e.g., ''
     */
    rootPath?: string;
}
/**
*  InMemoryBackendService configuration options
*  Usage:
*    InMemoryWebApiModule.forRoot(InMemHeroService, {delay: 600})
*
*  or if providing separately:
*    provide(InMemoryBackendConfig, {useValue: {delay: 600}}),
*/
export declare class InMemoryBackendConfig implements InMemoryBackendConfigArgs {
    constructor(config?: InMemoryBackendConfigArgs);
    static ɵfac: ɵngcc0.ɵɵFactoryDef<InMemoryBackendConfig, never>;
    static ɵprov: ɵngcc0.ɵɵInjectableDef<InMemoryBackendConfig>;
}
/** Return information (UriInfo) about a URI  */
export declare function parseUri(str: string): UriInfo;
/**
 *
 * Interface for the result of the `parseRequestUrl` method:
 *   Given URL "http://localhost:8080/api/customers/42?foo=1 the default implementation returns
 *     base: 'api/'
 *     collectionName: 'customers'
 *     id: '42'
 *     query: this.createQuery('foo=1')
 *     resourceUrl: 'http://localhost/api/customers/'
 */
export interface ParsedRequestUrl {
    apiBase: string;
    collectionName: string;
    id: string;
    query: Map<string, string[]>;
    resourceUrl: string;
}
export interface PassThruBackend {
    /**
     * Handle an HTTP request and return an Observable of HTTP response
     * Both the request type and the response type are determined by the supporting HTTP library.
     */
    handle(req: any): Observable<any>;
}
export declare function removeTrailingSlash(path: string): string;
/**
 *  Minimum definition needed by base class
 */
export interface RequestCore {
    url: string;
    urlWithParams?: string;
}
/**
* Interface for object w/ info about the current request url
* extracted from an Http Request.
* Also holds utility methods and configuration data from this service
*/
export interface RequestInfo {
    req: RequestCore;
    apiBase: string;
    collectionName: string;
    collection: any;
    headers: HeadersCore;
    method: string;
    id: any;
    query: Map<string, string[]>;
    resourceUrl: string;
    url: string;
    utils: RequestInfoUtilities;
}
/**
 * Interface for utility methods from this service instance.
 * Useful within an HTTP method override
 */
export interface RequestInfoUtilities {
    /**
     * Create a cold response Observable from a factory for ResponseOptions
     * the same way that the in-mem backend service does.
     * @param resOptionsFactory - creates ResponseOptions when observable is subscribed
     * @param withDelay - if true (default), add simulated latency delay from configuration
     */
    createResponse$: (resOptionsFactory: () => ResponseOptions) => Observable<any>;
    /**
     * Find first instance of item in collection by `item.id`
     * @param collection
     * @param id
     */
    findById<T extends {
        id: any;
    }>(collection: T[], id: any): T;
    /** return the current, active configuration which is a blend of defaults and overrides */
    getConfig(): InMemoryBackendConfigArgs;
    /** Get the in-mem service's copy of the "database" */
    getDb(): {};
    /** Get JSON body from the request object */
    getJsonBody(req: any): any;
    /** Get location info from a url, even on server where `document` is not defined */
    getLocation(url: string): UriInfo;
    /** Get (or create) the "real" backend */
    getPassThruBackend(): PassThruBackend;
    /**
     * return true if can determine that the collection's `item.id` is a number
     * */
    isCollectionIdNumeric<T extends {
        id: any;
    }>(collection: T[], collectionName: string): boolean;
    /**
     * Parses the request URL into a `ParsedRequestUrl` object.
     * Parsing depends upon certain values of `config`: `apiBase`, `host`, and `urlRoot`.
     */
    parseRequestUrl(url: string): ParsedRequestUrl;
}
/**
 * Provide a `responseInterceptor` method of this type in your `inMemDbService` to
 * morph the response options created in the `collectionHandler`.
 */
export declare type ResponseInterceptor = (res: ResponseOptions, ri: RequestInfo) => ResponseOptions;
export interface ResponseOptions {
    /**
     * String, Object, ArrayBuffer or Blob representing the body of the {@link Response}.
     */
    body?: string | Object | ArrayBuffer | Blob;
    /**
     * Response headers
     */
    headers?: HeadersCore;
    /**
     * Http {@link http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html status code}
     * associated with the response.
     */
    status?: number;
    /**
     * Status text for the status code
     */
    statusText?: string;
    /**
     * request url
     */
    url?: string;
}
/** Interface of information about a Uri  */
export interface UriInfo {
    source: string;
    protocol: string;
    authority: string;
    userInfo: string;
    user: string;
    password: string;
    host: string;
    port: string;
    relative: string;
    path: string;
    directory: string;
    file: string;
    query: string;
    anchor: string;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW50ZXJmYWNlcy5kLnRzIiwic291cmNlcyI6WyJpbnRlcmZhY2VzLmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xyXG4vKipcclxuICogIE1pbmltdW0gZGVmaW5pdGlvbiBuZWVkZWQgYnkgYmFzZSBjbGFzc1xyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBIZWFkZXJzQ29yZSB7XHJcbiAgICBzZXQobmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKTogdm9pZCB8IGFueTtcclxufVxyXG4vKipcclxuKiBJbnRlcmZhY2UgZm9yIGEgY2xhc3MgdGhhdCBjcmVhdGVzIGFuIGluLW1lbW9yeSBkYXRhYmFzZVxyXG4qXHJcbiogSXRzIGBjcmVhdGVEYmAgbWV0aG9kIGNyZWF0ZXMgYSBoYXNoIG9mIG5hbWVkIGNvbGxlY3Rpb25zIHRoYXQgcmVwcmVzZW50cyB0aGUgZGF0YWJhc2VcclxuKlxyXG4qIEZvciBtYXhpbXVtIGZsZXhpYmlsaXR5LCB0aGUgc2VydmljZSBtYXkgZGVmaW5lIEhUVFAgbWV0aG9kIG92ZXJyaWRlcy5cclxuKiBTdWNoIG1ldGhvZHMgbXVzdCBtYXRjaCB0aGUgc3BlbGxpbmcgb2YgYW4gSFRUUCBtZXRob2QgaW4gbG93ZXIgY2FzZSAoZS5nLCBcImdldFwiKS5cclxuKiBJZiBhIHJlcXVlc3QgaGFzIGEgbWF0Y2hpbmcgbWV0aG9kLCBpdCB3aWxsIGJlIGNhbGxlZCBhcyBpblxyXG4qIGBnZXQoaW5mbzogcmVxdWVzdEluZm8sIGRiOiB7fSlgIHdoZXJlIGBkYmAgaXMgdGhlIGRhdGFiYXNlIG9iamVjdCBkZXNjcmliZWQgYWJvdmUuXHJcbiovXHJcbmV4cG9ydCBkZWNsYXJlIGFic3RyYWN0IGNsYXNzIEluTWVtb3J5RGJTZXJ2aWNlIHtcclxuICAgIC8qKlxyXG4gICAgKiBDcmVhdGVzIGFuIGluLW1lbW9yeSBcImRhdGFiYXNlXCIgaGFzaCB3aG9zZSBrZXlzIGFyZSBjb2xsZWN0aW9uIG5hbWVzXHJcbiAgICAqIGFuZCB3aG9zZSB2YWx1ZXMgYXJlIGFycmF5cyBvZiBjb2xsZWN0aW9uIG9iamVjdHMgdG8gcmV0dXJuIG9yIHVwZGF0ZS5cclxuICAgICpcclxuICAgICogcmV0dXJucyBPYnNlcnZhYmxlIG9mIHRoZSBkYXRhYmFzZSBiZWNhdXNlIGNvdWxkIGhhdmUgdG8gY3JlYXRlIGl0IGFzeW5jaHJvbm91c2x5LlxyXG4gICAgKlxyXG4gICAgKiBUaGlzIG1ldGhvZCBtdXN0IGJlIHNhZmUgdG8gY2FsbCByZXBlYXRlZGx5LlxyXG4gICAgKiBFYWNoIHRpbWUgaXQgc2hvdWxkIHJldHVybiBhIG5ldyBvYmplY3Qgd2l0aCBuZXcgYXJyYXlzIGNvbnRhaW5pbmcgbmV3IGl0ZW0gb2JqZWN0cy5cclxuICAgICogVGhpcyBjb25kaXRpb24gYWxsb3dzIHRoZSBpbi1tZW1vcnkgYmFja2VuZCBzZXJ2aWNlIHRvIG11dGF0ZSB0aGUgY29sbGVjdGlvbnNcclxuICAgICogYW5kIHRoZWlyIGl0ZW1zIHdpdGhvdXQgdG91Y2hpbmcgdGhlIG9yaWdpbmFsIHNvdXJjZSBkYXRhLlxyXG4gICAgKlxyXG4gICAgKiBUaGUgaW4tbWVtIGJhY2tlbmQgc2VydmljZSBjYWxscyB0aGlzIG1ldGhvZCB3aXRob3V0IGEgdmFsdWUgdGhlIGZpcnN0IHRpbWUuXHJcbiAgICAqIFRoZSBzZXJ2aWNlIGNhbGxzIGl0IHdpdGggdGhlIGBSZXF1ZXN0SW5mb2Agd2hlbiBpdCByZWNlaXZlcyBhIFBPU1QgYGNvbW1hbmRzL3Jlc2V0RGJgIHJlcXVlc3QuXHJcbiAgICAqIFlvdXIgSW5NZW1vcnlEYlNlcnZpY2UgY2FuIGFkanVzdCBpdHMgYmVoYXZpb3IgYWNjb3JkaW5nbHkuXHJcbiAgICAqL1xyXG4gICAgYWJzdHJhY3QgY3JlYXRlRGIocmVxSW5mbz86IFJlcXVlc3RJbmZvKToge30gfCBPYnNlcnZhYmxlPHt9PiB8IFByb21pc2U8e30+O1xyXG59XHJcbi8qKlxyXG4qIEludGVyZmFjZSBmb3IgSW5NZW1vcnlCYWNrZW5kIGNvbmZpZ3VyYXRpb24gb3B0aW9uc1xyXG4qL1xyXG5leHBvcnQgZGVjbGFyZSBhYnN0cmFjdCBjbGFzcyBJbk1lbW9yeUJhY2tlbmRDb25maWdBcmdzIHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGJhc2UgcGF0aCB0byB0aGUgYXBpLCBlLmcsICdhcGkvJy5cclxuICAgICAqIElmIG5vdCBzcGVjaWZpZWQgdGhhbiBgcGFyc2VSZXF1ZXN0VXJsYCBhc3N1bWVzIGl0IGlzIHRoZSBmaXJzdCBwYXRoIHNlZ21lbnQgaW4gdGhlIHJlcXVlc3QuXHJcbiAgICAgKi9cclxuICAgIGFwaUJhc2U/OiBzdHJpbmc7XHJcbiAgICAvKipcclxuICAgICAqIGZhbHNlIChkZWZhdWx0KSBpZiBzZWFyY2ggbWF0Y2ggc2hvdWxkIGJlIGNhc2UgaW5zZW5zaXRpdmVcclxuICAgICAqL1xyXG4gICAgY2FzZVNlbnNpdGl2ZVNlYXJjaD86IGJvb2xlYW47XHJcbiAgICAvKipcclxuICAgICAqIGZhbHNlIChkZWZhdWx0KSBwdXQgY29udGVudCBkaXJlY3RseSBpbnNpZGUgdGhlIHJlc3BvbnNlIGJvZHkuXHJcbiAgICAgKiB0cnVlOiBlbmNhcHN1bGF0ZSBjb250ZW50IGluIGEgYGRhdGFgIHByb3BlcnR5IGluc2lkZSB0aGUgcmVzcG9uc2UgYm9keSwgYHsgZGF0YTogLi4uIH1gLlxyXG4gICAgICovXHJcbiAgICBkYXRhRW5jYXBzdWxhdGlvbj86IGJvb2xlYW47XHJcbiAgICAvKipcclxuICAgICAqIGRlbGF5IChpbiBtcykgdG8gc2ltdWxhdGUgbGF0ZW5jeVxyXG4gICAgICovXHJcbiAgICBkZWxheT86IG51bWJlcjtcclxuICAgIC8qKlxyXG4gICAgICogZmFsc2UgKGRlZmF1bHQpIHNob3VsZCAyMDQgd2hlbiBvYmplY3QtdG8tZGVsZXRlIG5vdCBmb3VuZDsgdHJ1ZTogNDA0XHJcbiAgICAgKi9cclxuICAgIGRlbGV0ZTQwND86IGJvb2xlYW47XHJcbiAgICAvKipcclxuICAgICAqIGhvc3QgZm9yIHRoaXMgc2VydmljZSwgZS5nLiwgJ2xvY2FsaG9zdCdcclxuICAgICAqL1xyXG4gICAgaG9zdD86IHN0cmluZztcclxuICAgIC8qKlxyXG4gICAgICogZmFsc2UgKGRlZmF1bHQpIHNob3VsZCBwYXNzIHVucmVjb2duaXplZCByZXF1ZXN0IFVSTCB0aHJvdWdoIHRvIG9yaWdpbmFsIGJhY2tlbmQ7IHRydWU6IDQwNFxyXG4gICAgICovXHJcbiAgICBwYXNzVGhydVVua25vd25Vcmw/OiBib29sZWFuO1xyXG4gICAgLyoqXHJcbiAgICAgKiB0cnVlIChkZWZhdWx0KSBzaG91bGQgTk9UIHJldHVybiB0aGUgaXRlbSAoMjA0KSBhZnRlciBhIFBPU1QuIGZhbHNlOiByZXR1cm4gdGhlIGl0ZW0gKDIwMCkuXHJcbiAgICAgKi9cclxuICAgIHBvc3QyMDQ/OiBib29sZWFuO1xyXG4gICAgLyoqXHJcbiAgICAqIGZhbHNlIChkZWZhdWx0KSBzaG91bGQgTk9UIHVwZGF0ZSBleGlzdGluZyBpdGVtIHdpdGggUE9TVC4gZmFsc2U6IE9LIHRvIHVwZGF0ZS5cclxuICAgICovXHJcbiAgICBwb3N0NDA5PzogYm9vbGVhbjtcclxuICAgIC8qKlxyXG4gICAgKiB0cnVlIChkZWZhdWx0KSBzaG91bGQgTk9UIHJldHVybiB0aGUgaXRlbSAoMjA0KSBhZnRlciBhIFBPU1QuIGZhbHNlOiByZXR1cm4gdGhlIGl0ZW0gKDIwMCkuXHJcbiAgICAqL1xyXG4gICAgcHV0MjA0PzogYm9vbGVhbjtcclxuICAgIC8qKlxyXG4gICAgICogZmFsc2UgKGRlZmF1bHQpIGlmIGl0ZW0gbm90IGZvdW5kLCBjcmVhdGUgYXMgbmV3IGl0ZW07IGZhbHNlOiBzaG91bGQgNDA0LlxyXG4gICAgICovXHJcbiAgICBwdXQ0MDQ/OiBib29sZWFuO1xyXG4gICAgLyoqXHJcbiAgICAgKiByb290IHBhdGggX2JlZm9yZV8gYW55IEFQSSBjYWxsLCBlLmcuLCAnJ1xyXG4gICAgICovXHJcbiAgICByb290UGF0aD86IHN0cmluZztcclxufVxyXG4vKipcclxuKiAgSW5NZW1vcnlCYWNrZW5kU2VydmljZSBjb25maWd1cmF0aW9uIG9wdGlvbnNcclxuKiAgVXNhZ2U6XHJcbiogICAgSW5NZW1vcnlXZWJBcGlNb2R1bGUuZm9yUm9vdChJbk1lbUhlcm9TZXJ2aWNlLCB7ZGVsYXk6IDYwMH0pXHJcbipcclxuKiAgb3IgaWYgcHJvdmlkaW5nIHNlcGFyYXRlbHk6XHJcbiogICAgcHJvdmlkZShJbk1lbW9yeUJhY2tlbmRDb25maWcsIHt1c2VWYWx1ZToge2RlbGF5OiA2MDB9fSksXHJcbiovXHJcbmV4cG9ydCBkZWNsYXJlIGNsYXNzIEluTWVtb3J5QmFja2VuZENvbmZpZyBpbXBsZW1lbnRzIEluTWVtb3J5QmFja2VuZENvbmZpZ0FyZ3Mge1xyXG4gICAgY29uc3RydWN0b3IoY29uZmlnPzogSW5NZW1vcnlCYWNrZW5kQ29uZmlnQXJncyk7XHJcbn1cclxuLyoqIFJldHVybiBpbmZvcm1hdGlvbiAoVXJpSW5mbykgYWJvdXQgYSBVUkkgICovXHJcbmV4cG9ydCBkZWNsYXJlIGZ1bmN0aW9uIHBhcnNlVXJpKHN0cjogc3RyaW5nKTogVXJpSW5mbztcclxuLyoqXHJcbiAqXHJcbiAqIEludGVyZmFjZSBmb3IgdGhlIHJlc3VsdCBvZiB0aGUgYHBhcnNlUmVxdWVzdFVybGAgbWV0aG9kOlxyXG4gKiAgIEdpdmVuIFVSTCBcImh0dHA6Ly9sb2NhbGhvc3Q6ODA4MC9hcGkvY3VzdG9tZXJzLzQyP2Zvbz0xIHRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHJldHVybnNcclxuICogICAgIGJhc2U6ICdhcGkvJ1xyXG4gKiAgICAgY29sbGVjdGlvbk5hbWU6ICdjdXN0b21lcnMnXHJcbiAqICAgICBpZDogJzQyJ1xyXG4gKiAgICAgcXVlcnk6IHRoaXMuY3JlYXRlUXVlcnkoJ2Zvbz0xJylcclxuICogICAgIHJlc291cmNlVXJsOiAnaHR0cDovL2xvY2FsaG9zdC9hcGkvY3VzdG9tZXJzLydcclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgUGFyc2VkUmVxdWVzdFVybCB7XHJcbiAgICBhcGlCYXNlOiBzdHJpbmc7XHJcbiAgICBjb2xsZWN0aW9uTmFtZTogc3RyaW5nO1xyXG4gICAgaWQ6IHN0cmluZztcclxuICAgIHF1ZXJ5OiBNYXA8c3RyaW5nLCBzdHJpbmdbXT47XHJcbiAgICByZXNvdXJjZVVybDogc3RyaW5nO1xyXG59XHJcbmV4cG9ydCBpbnRlcmZhY2UgUGFzc1RocnVCYWNrZW5kIHtcclxuICAgIC8qKlxyXG4gICAgICogSGFuZGxlIGFuIEhUVFAgcmVxdWVzdCBhbmQgcmV0dXJuIGFuIE9ic2VydmFibGUgb2YgSFRUUCByZXNwb25zZVxyXG4gICAgICogQm90aCB0aGUgcmVxdWVzdCB0eXBlIGFuZCB0aGUgcmVzcG9uc2UgdHlwZSBhcmUgZGV0ZXJtaW5lZCBieSB0aGUgc3VwcG9ydGluZyBIVFRQIGxpYnJhcnkuXHJcbiAgICAgKi9cclxuICAgIGhhbmRsZShyZXE6IGFueSk6IE9ic2VydmFibGU8YW55PjtcclxufVxyXG5leHBvcnQgZGVjbGFyZSBmdW5jdGlvbiByZW1vdmVUcmFpbGluZ1NsYXNoKHBhdGg6IHN0cmluZyk6IHN0cmluZztcclxuLyoqXHJcbiAqICBNaW5pbXVtIGRlZmluaXRpb24gbmVlZGVkIGJ5IGJhc2UgY2xhc3NcclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgUmVxdWVzdENvcmUge1xyXG4gICAgdXJsOiBzdHJpbmc7XHJcbiAgICB1cmxXaXRoUGFyYW1zPzogc3RyaW5nO1xyXG59XHJcbi8qKlxyXG4qIEludGVyZmFjZSBmb3Igb2JqZWN0IHcvIGluZm8gYWJvdXQgdGhlIGN1cnJlbnQgcmVxdWVzdCB1cmxcclxuKiBleHRyYWN0ZWQgZnJvbSBhbiBIdHRwIFJlcXVlc3QuXHJcbiogQWxzbyBob2xkcyB1dGlsaXR5IG1ldGhvZHMgYW5kIGNvbmZpZ3VyYXRpb24gZGF0YSBmcm9tIHRoaXMgc2VydmljZVxyXG4qL1xyXG5leHBvcnQgaW50ZXJmYWNlIFJlcXVlc3RJbmZvIHtcclxuICAgIHJlcTogUmVxdWVzdENvcmU7XHJcbiAgICBhcGlCYXNlOiBzdHJpbmc7XHJcbiAgICBjb2xsZWN0aW9uTmFtZTogc3RyaW5nO1xyXG4gICAgY29sbGVjdGlvbjogYW55O1xyXG4gICAgaGVhZGVyczogSGVhZGVyc0NvcmU7XHJcbiAgICBtZXRob2Q6IHN0cmluZztcclxuICAgIGlkOiBhbnk7XHJcbiAgICBxdWVyeTogTWFwPHN0cmluZywgc3RyaW5nW10+O1xyXG4gICAgcmVzb3VyY2VVcmw6IHN0cmluZztcclxuICAgIHVybDogc3RyaW5nO1xyXG4gICAgdXRpbHM6IFJlcXVlc3RJbmZvVXRpbGl0aWVzO1xyXG59XHJcbi8qKlxyXG4gKiBJbnRlcmZhY2UgZm9yIHV0aWxpdHkgbWV0aG9kcyBmcm9tIHRoaXMgc2VydmljZSBpbnN0YW5jZS5cclxuICogVXNlZnVsIHdpdGhpbiBhbiBIVFRQIG1ldGhvZCBvdmVycmlkZVxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBSZXF1ZXN0SW5mb1V0aWxpdGllcyB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhIGNvbGQgcmVzcG9uc2UgT2JzZXJ2YWJsZSBmcm9tIGEgZmFjdG9yeSBmb3IgUmVzcG9uc2VPcHRpb25zXHJcbiAgICAgKiB0aGUgc2FtZSB3YXkgdGhhdCB0aGUgaW4tbWVtIGJhY2tlbmQgc2VydmljZSBkb2VzLlxyXG4gICAgICogQHBhcmFtIHJlc09wdGlvbnNGYWN0b3J5IC0gY3JlYXRlcyBSZXNwb25zZU9wdGlvbnMgd2hlbiBvYnNlcnZhYmxlIGlzIHN1YnNjcmliZWRcclxuICAgICAqIEBwYXJhbSB3aXRoRGVsYXkgLSBpZiB0cnVlIChkZWZhdWx0KSwgYWRkIHNpbXVsYXRlZCBsYXRlbmN5IGRlbGF5IGZyb20gY29uZmlndXJhdGlvblxyXG4gICAgICovXHJcbiAgICBjcmVhdGVSZXNwb25zZSQ6IChyZXNPcHRpb25zRmFjdG9yeTogKCkgPT4gUmVzcG9uc2VPcHRpb25zKSA9PiBPYnNlcnZhYmxlPGFueT47XHJcbiAgICAvKipcclxuICAgICAqIEZpbmQgZmlyc3QgaW5zdGFuY2Ugb2YgaXRlbSBpbiBjb2xsZWN0aW9uIGJ5IGBpdGVtLmlkYFxyXG4gICAgICogQHBhcmFtIGNvbGxlY3Rpb25cclxuICAgICAqIEBwYXJhbSBpZFxyXG4gICAgICovXHJcbiAgICBmaW5kQnlJZDxUIGV4dGVuZHMge1xyXG4gICAgICAgIGlkOiBhbnk7XHJcbiAgICB9Pihjb2xsZWN0aW9uOiBUW10sIGlkOiBhbnkpOiBUO1xyXG4gICAgLyoqIHJldHVybiB0aGUgY3VycmVudCwgYWN0aXZlIGNvbmZpZ3VyYXRpb24gd2hpY2ggaXMgYSBibGVuZCBvZiBkZWZhdWx0cyBhbmQgb3ZlcnJpZGVzICovXHJcbiAgICBnZXRDb25maWcoKTogSW5NZW1vcnlCYWNrZW5kQ29uZmlnQXJncztcclxuICAgIC8qKiBHZXQgdGhlIGluLW1lbSBzZXJ2aWNlJ3MgY29weSBvZiB0aGUgXCJkYXRhYmFzZVwiICovXHJcbiAgICBnZXREYigpOiB7fTtcclxuICAgIC8qKiBHZXQgSlNPTiBib2R5IGZyb20gdGhlIHJlcXVlc3Qgb2JqZWN0ICovXHJcbiAgICBnZXRKc29uQm9keShyZXE6IGFueSk6IGFueTtcclxuICAgIC8qKiBHZXQgbG9jYXRpb24gaW5mbyBmcm9tIGEgdXJsLCBldmVuIG9uIHNlcnZlciB3aGVyZSBgZG9jdW1lbnRgIGlzIG5vdCBkZWZpbmVkICovXHJcbiAgICBnZXRMb2NhdGlvbih1cmw6IHN0cmluZyk6IFVyaUluZm87XHJcbiAgICAvKiogR2V0IChvciBjcmVhdGUpIHRoZSBcInJlYWxcIiBiYWNrZW5kICovXHJcbiAgICBnZXRQYXNzVGhydUJhY2tlbmQoKTogUGFzc1RocnVCYWNrZW5kO1xyXG4gICAgLyoqXHJcbiAgICAgKiByZXR1cm4gdHJ1ZSBpZiBjYW4gZGV0ZXJtaW5lIHRoYXQgdGhlIGNvbGxlY3Rpb24ncyBgaXRlbS5pZGAgaXMgYSBudW1iZXJcclxuICAgICAqICovXHJcbiAgICBpc0NvbGxlY3Rpb25JZE51bWVyaWM8VCBleHRlbmRzIHtcclxuICAgICAgICBpZDogYW55O1xyXG4gICAgfT4oY29sbGVjdGlvbjogVFtdLCBjb2xsZWN0aW9uTmFtZTogc3RyaW5nKTogYm9vbGVhbjtcclxuICAgIC8qKlxyXG4gICAgICogUGFyc2VzIHRoZSByZXF1ZXN0IFVSTCBpbnRvIGEgYFBhcnNlZFJlcXVlc3RVcmxgIG9iamVjdC5cclxuICAgICAqIFBhcnNpbmcgZGVwZW5kcyB1cG9uIGNlcnRhaW4gdmFsdWVzIG9mIGBjb25maWdgOiBgYXBpQmFzZWAsIGBob3N0YCwgYW5kIGB1cmxSb290YC5cclxuICAgICAqL1xyXG4gICAgcGFyc2VSZXF1ZXN0VXJsKHVybDogc3RyaW5nKTogUGFyc2VkUmVxdWVzdFVybDtcclxufVxyXG4vKipcclxuICogUHJvdmlkZSBhIGByZXNwb25zZUludGVyY2VwdG9yYCBtZXRob2Qgb2YgdGhpcyB0eXBlIGluIHlvdXIgYGluTWVtRGJTZXJ2aWNlYCB0b1xyXG4gKiBtb3JwaCB0aGUgcmVzcG9uc2Ugb3B0aW9ucyBjcmVhdGVkIGluIHRoZSBgY29sbGVjdGlvbkhhbmRsZXJgLlxyXG4gKi9cclxuZXhwb3J0IGRlY2xhcmUgdHlwZSBSZXNwb25zZUludGVyY2VwdG9yID0gKHJlczogUmVzcG9uc2VPcHRpb25zLCByaTogUmVxdWVzdEluZm8pID0+IFJlc3BvbnNlT3B0aW9ucztcclxuZXhwb3J0IGludGVyZmFjZSBSZXNwb25zZU9wdGlvbnMge1xyXG4gICAgLyoqXHJcbiAgICAgKiBTdHJpbmcsIE9iamVjdCwgQXJyYXlCdWZmZXIgb3IgQmxvYiByZXByZXNlbnRpbmcgdGhlIGJvZHkgb2YgdGhlIHtAbGluayBSZXNwb25zZX0uXHJcbiAgICAgKi9cclxuICAgIGJvZHk/OiBzdHJpbmcgfCBPYmplY3QgfCBBcnJheUJ1ZmZlciB8IEJsb2I7XHJcbiAgICAvKipcclxuICAgICAqIFJlc3BvbnNlIGhlYWRlcnNcclxuICAgICAqL1xyXG4gICAgaGVhZGVycz86IEhlYWRlcnNDb3JlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBIdHRwIHtAbGluayBodHRwOi8vd3d3LnczLm9yZy9Qcm90b2NvbHMvcmZjMjYxNi9yZmMyNjE2LXNlYzEwLmh0bWwgc3RhdHVzIGNvZGV9XHJcbiAgICAgKiBhc3NvY2lhdGVkIHdpdGggdGhlIHJlc3BvbnNlLlxyXG4gICAgICovXHJcbiAgICBzdGF0dXM/OiBudW1iZXI7XHJcbiAgICAvKipcclxuICAgICAqIFN0YXR1cyB0ZXh0IGZvciB0aGUgc3RhdHVzIGNvZGVcclxuICAgICAqL1xyXG4gICAgc3RhdHVzVGV4dD86IHN0cmluZztcclxuICAgIC8qKlxyXG4gICAgICogcmVxdWVzdCB1cmxcclxuICAgICAqL1xyXG4gICAgdXJsPzogc3RyaW5nO1xyXG59XHJcbi8qKiBJbnRlcmZhY2Ugb2YgaW5mb3JtYXRpb24gYWJvdXQgYSBVcmkgICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXJpSW5mbyB7XHJcbiAgICBzb3VyY2U6IHN0cmluZztcclxuICAgIHByb3RvY29sOiBzdHJpbmc7XHJcbiAgICBhdXRob3JpdHk6IHN0cmluZztcclxuICAgIHVzZXJJbmZvOiBzdHJpbmc7XHJcbiAgICB1c2VyOiBzdHJpbmc7XHJcbiAgICBwYXNzd29yZDogc3RyaW5nO1xyXG4gICAgaG9zdDogc3RyaW5nO1xyXG4gICAgcG9ydDogc3RyaW5nO1xyXG4gICAgcmVsYXRpdmU6IHN0cmluZztcclxuICAgIHBhdGg6IHN0cmluZztcclxuICAgIGRpcmVjdG9yeTogc3RyaW5nO1xyXG4gICAgZmlsZTogc3RyaW5nO1xyXG4gICAgcXVlcnk6IHN0cmluZztcclxuICAgIGFuY2hvcjogc3RyaW5nO1xyXG59XHJcbiJdfQ==